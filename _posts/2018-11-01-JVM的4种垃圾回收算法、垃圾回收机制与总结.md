---
layout:     post
title: JVM的4种垃圾回收算法、垃圾回收机制与总结
date: 2018-11-01
author: Tandy
header-img: img/post-bg-2015.jpg
catalog: true
tags: JVM
grammar_code: true
---

在主流的商用程序语言的主流实现中，都是从通过可达性分析(Reachability Analysis)来判定对象否是存活的，
这个算法的基本思路就是通过一系列称为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain),
当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，所以它们将会被判定为是可回收的对象。

即使在可达性分析算法中不可达的对象，也并非是"非死不可"的，这时候它们暂时处于"缓刑"阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：
 1. 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()
 方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为"没有必要执行"。
 2. 如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()
中成功拯救自己----只要重新与引用链上的任何一个对象建立关联即可，譬如把自己(this关键字)赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出
"即将回收"的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。

在Java语言中，可作为GC Roots的对象包括下面几种：
 - 虚拟机栈(栈帧中的本地变量表)中引用的对象
 - 方法区中类静态属性引用的对象
 - 方法区中常量引用的对象
 - 本地方法栈中JNI(即一般说的Native方法)引用的对象

## JVM的4种垃圾回收算法
### 垃圾收集算法
 #### 1. 标记-清除
 
标记-清除算法将垃圾回收分为两个阶段：**标记阶段和清除阶段**。

在标记阶段首先通过**根节点(GC Roots)**，标记所有从根节点开始的对象，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。

![](https://raw.githubusercontent.com/tanzhouwen/tanzhouwen.github.io/master/images/jvm-gc-marker-clear.jpg)

##### 适用场合：

 - 存活对象较多的情况下比较高效
 - 适用于老年代
##### 缺点：

 - 容易产生大量不连续的内存碎片，可能会导致以后在程序运行过程中需要分配较大对象时，无法找个足够连续内存而不得不提前触发另一次垃圾收集动作。
 - 扫描了整个空间两次（第一次：标记存活对象；第二次：清除没有标记的对象）

#### 2. 复制算法

从根节点(GC Roots)进行扫描，标记出所有的存活对象，并将这些存活的对象复制到另一块新的内存（图中下边的那一块内存Survivor1）上去，当Survivor1没有足够空间存放上一次收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代，之后将原来的那一块内存（图中上边的那一块儿内存Survivor0）全部回收掉，**现在的商业虚拟机都采用这种收集算法来回收新生代**。

![](https://raw.githubusercontent.com/tanzhouwen/tanzhouwen.github.io/master/images/jvm-gc-copy.jpg)

##### 适用场合：

 - 存活对象较少的情况下比较高效
 - 扫描了整个空间一次（标记存活对象并复制移动）
 - 适用于新生代：基本上98%的对象是”朝生夕死”的，存活下来的会很少
##### 缺点：

 - 需要一块空的内存空间，将内存缩小为了原来的一半
 - 需要复制移动对象
 
#### 3. 标记-整理

复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。

这种情况在新生代经常发生，但是在老年代更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活的对象较多，复制的成本也将很高。

![](https://raw.githubusercontent.com/tanzhouwen/tanzhouwen.github.io/master/images/jvm-gc-marker-sort.jpg)

标记整理算法是一种老年代的回收算法，它在标记-清除算法的基础上做了一些优化。

首先也需要从根节点(GC Roots)开始对所有可达对象做一次标记，但之后，它并不简单地清理未标记的对象，而是将所有的存活对象移动到内存的一端。之后，清理边界外所有的空间。这种方法既避免了碎片的产生，又不需要两块相同的内存空间，因此，其性价比比较高。

#### 4. 分代收集算法

当前商业虚拟机的垃圾收集都采用**分代收集算法**，它解决了标记整理不适用于老年代的问题，将内存分代。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。

在不同年代使用不同的算法，从而使用最合适的算法，新生代存活率低，可以使用复制算法。而老年代对象存活率高，没有额外空间对它进行分配担保，所以只能使用标记-清除或者标记-整理算法。
![](https://raw.githubusercontent.com/tanzhouwen/tanzhouwen.github.io/master/images/jvm-gc-generational-collection.jpg)

> [转载：http://youzhixueyuan.com/jvm-garbage-collection-algorithm.html](http://youzhixueyuan.com/jvm-garbage-collection-algorithm.html)
